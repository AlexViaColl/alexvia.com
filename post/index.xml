<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Alex Via</title>
    <link>https://alexvia.com/post/</link>
    <description>Recent content in Posts on Alex Via</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Mon, 13 Dec 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://alexvia.com/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Advent of Code 2021 (Days 6-12)</title>
      <link>https://alexvia.com/post/006_advent_of_code_2021_days_6_12/</link>
      <pubDate>Mon, 13 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://alexvia.com/post/006_advent_of_code_2021_days_6_12/</guid>
      <description>Following up on the last post, I continue to solve Advent of Code puzzles using a different programming language every day.
You can find my solutions on GitHub:

For the second week I chose languages which I had never used before.
Day 6 - Perl Day 7 - Ada Day 8 - PHP Day 9 - D Day 10 - Nim Day 11 - Julia Day 12 - Dart After struggling with functional languages last time, this second week has been a bit easier. I got used to the new languages pretty fast, as they share many concepts with other languages that I&amp;rsquo;m already familiar with.</description>
    </item>
    
    <item>
      <title>Advent of Code 2021 (Days 1-5)</title>
      <link>https://alexvia.com/post/005_advent_of_code_2021_days_1_5/</link>
      <pubDate>Mon, 06 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://alexvia.com/post/005_advent_of_code_2021_days_1_5/</guid>
      <description>Advent of Code is an online Advent calendar where you have to solve two small programming puzzles, of increasing difficulty, every day from December 1st to the 25th.
Last year, I solved most of the problems using Rust. The challenge for this year is to use a different programming language every day, based on Tsoding.
You can find my solutions on GitHub: 
For the first 5 days I decided to use functional programming languages (mostly).
Day 1 - Haskell Day 2 - Ruby Day 3 - OCaml Day 4 - Scala Day 5 - Erlang This first week turned out to be quite a challenge.</description>
    </item>
    
    <item>
      <title>Checking file integrity using the GitLab API</title>
      <link>https://alexvia.com/post/004_file_integrity_gitlab_api/</link>
      <pubDate>Sun, 28 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://alexvia.com/post/004_file_integrity_gitlab_api/</guid>
      <description>The other day at work I needed a way to verify the integrity of a file under source control (GitLab) against a local copy of the same file, which was potentially modified or outdated.
I decided to take the opportunity to learn a bit about using the GitLab API. Here&amp;rsquo;s a breakdown of what I learned:
 How to create, use and manage access tokens. Access the GitLab API programmatically using JavaScript. How to compare files &amp;ldquo;by hash&amp;rdquo; instead of by content.  Creating an Access Token Depending on what endpoints of the GitLab API you need to access, a personal access token might be required.</description>
    </item>
    
    <item>
      <title>Playing a Sound with ALSA</title>
      <link>https://alexvia.com/post/003_alsa_playback/</link>
      <pubDate>Fri, 19 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://alexvia.com/post/003_alsa_playback/</guid>
      <description>The Advanced Linux Sound Architecture (ALSA) project is used to implement sound card drivers in Linux. Apart from the Kernel API, ALSA also provides a library API exposing the same functionality as the Kernel API but with a simpler and more usable interface. In this post, we will explore how the PCM Interface can be used for sound playback.
There are quite a few options for dealing with audio on Linux. On one hand, we have high level libraries such as SDL or OpenAL that allow us to play a sound with a few lines of code. Then we also have entire frameworks devoted to multimedia such as GStreamer.</description>
    </item>
    
    <item>
      <title>Initializing OpenGL in X11</title>
      <link>https://alexvia.com/post/002_initializing_opengl_on_x11/</link>
      <pubDate>Sat, 13 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://alexvia.com/post/002_initializing_opengl_on_x11/</guid>
      <description>In the last post, we created a simple program to open an X11 window. Today, we will learn how to initialize and use OpenGL to clear the window with a color.

And the result: Linking with OpenGL In order to use OpenGL we need to include the following headers:
#include &amp;lt;X11/Xutil.h&amp;gt;	// Required to use XVisualInfo #include &amp;lt;GL/gl.h&amp;gt; // OpenGL types and functions like GLuint or glClear #include &amp;lt;GL/glx.h&amp;gt;	// OpenGL X Window bindings like glXCreateContext  And we also need to tell the compiler to link with OpenGL:
# using pkg-config gcc -o x11_opengl `pkg-config --libs x11 gl` x11_opengl.</description>
    </item>
    
    <item>
      <title>Opening a Window in X11</title>
      <link>https://alexvia.com/post/001_xlib_opening_window/</link>
      <pubDate>Sun, 07 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://alexvia.com/post/001_xlib_opening_window/</guid>
      <description>The X Window System is a windowing system commonly used in UNIX-based operating systems. The latest version of X is version 11 (released 2012), that&amp;rsquo;s why it&amp;rsquo;s often abbreviated as X11.
X11 is based on a client-server architecture. The server is the one who has direct access over the hardware devices such as the monitor screens, the keyboard and the mouse. Client applications should make requests to the server in order to achieve any kind of graphical output to the screen.
X is not the only Window System available for Linux and other UNIX-like operating systems. Wayland is a more modern project with the aim of replacing X.</description>
    </item>
    
    <item>
      <title>8 Uses of Pointers in C</title>
      <link>https://alexvia.com/post/000_uses_of_pointers_in_c/</link>
      <pubDate>Sun, 31 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://alexvia.com/post/000_uses_of_pointers_in_c/</guid>
      <description>At a fundamental level a pointer is just a number which represents a memory address. The size of a pointer depends on the platform, for 64 bit platforms the size is 64 bits (8 bytes) and for 32 bit platforms the size is 32 bits (4 bytes), but the size is always the same for a given platform regardless of the pointer&amp;rsquo;s type.
printf(&amp;quot;%d\n&amp;quot;, sizeof(int*)); printf(&amp;quot;%d\n&amp;quot;, sizeof(char*)); printf(&amp;quot;%d\n&amp;quot;, sizeof(void*)); printf(&amp;quot;%d\n&amp;quot;, sizeof(MyCustomType*));  A memory address specifies the location of a single byte in memory, if we wanted to read only a single bit from memory, we would have to read a whole byte and then do some bit twiddling to extract the bit we were interested in.</description>
    </item>
    
  </channel>
</rss>
