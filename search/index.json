[{"content":"Advent of Code is an online Advent calendar where you have to solve two small programming puzzles, of increasing difficulty, every day from December 1st to the 25th.\nLast year, I solved most of the problems using Rust. The challenge for this year is to use a different programming language every day, based on Tsoding.\nYou can find my solutions on GitHub: \nFor the first 5 days I decided to use functional programming languages (mostly).\nDay 1 - Haskell Day 2 - Ruby Day 3 - OCaml Day 4 - Scala Day 5 - Erlang This first week turned out to be quite a challenge. I had never before programmed using Haskell, OCaml, Scala nor Erlang.\nMy solutions probably aren\u0026rsquo;t the most elegant ones out there, but I managed to get away without using the imperative features of these languages.\nAnd I learned a few new things along the way, such as:\n List comprehension Partially applied functions Pattern matching Tail recursion  I\u0026rsquo;m looking forward to get better using functional programming languages in the future.\n","date":"2021-12-06","permalink":"https://alexvia.com/post/005_advent_of_code_2021_days_1_5/","tags":["programming"],"title":"Advent of Code 2021 (Days 1-5)"},{"content":"The other day at work I needed a way to verify the integrity of a file under source control (GitLab) against a local copy of the same file, which was potentially modified or outdated.\nI decided to take the opportunity to learn a bit about using the GitLab API. Here\u0026rsquo;s a breakdown of what I learned:\n How to create, use and manage access tokens. Access the GitLab API programmatically using JavaScript. How to compare files \u0026ldquo;by hash\u0026rdquo; instead of by content.  Creating an Access Token Depending on what endpoints of the GitLab API you need to access, a personal access token might be required.\nIn my case, I needed read access to a private repository, therefore I created a personal token with the read_repository scope selected.\nThe steps to create the access token are as follows:\n Navigate to the Access Tokens page Enter a token name, expiration date and select the desired scopes.  Click on Create personal access token and make sure to save the token somewhere.  Using the GitLab API According to the GitLab doc we can use the /projects/:id/repository/files/:file_path endpoint to query information about a file in the repository such as the name, size or content.\nThe project id can be found in the main page of the repository and the file path is the URL encoded full path to the file from the root of the repository.\nThe documentation also comes with an example request using curl but we are going to use Node.js.\nInstead of using the https module that comes with Node.js by default, we are going to use the package node-fetch so we can use the same Fetch API so our code can run both in a browser environment as well as in a server (Node.js) environment.\nSo first things first, let\u0026rsquo;s install node-fetch using npm.\n$ npm install node-fetch  \nThe code necessary to query a file from our GitLab repository might look something like this:\n// main.mjs import fetch from 'node-fetch'; async function queryFile(filePath) { const gitlabToken = '\u0026lt;YOUR ACCESS TOKEN\u0026gt;'; const projectId = 31501495; const uriPath = encodeURIComponent(filePath); const branchName = 'main'; const host = 'https://gitlab.com'; const url = `${host}/api/v4/projects/${projectId}` + `/repository/files/${uriPath}?ref=${branchName}`; const response = await fetch(url, { method: \u0026quot;GET\u0026quot;, headers: { \u0026quot;Content-Type\u0026quot;: \u0026quot;application/json\u0026quot;, \u0026quot;PRIVATE-TOKEN\u0026quot;: gitlabToken, }, }); const json = await response.json(); return json; } const fileInfo = await queryFile(\u0026quot;src/main.js\u0026quot;); console.log(fileInfo);  \nWe can run it like this:\n$ node main.mjs  \nAnd the result looks like this:\nNOTE: You can also remove the import from the first line and run the exact same code from the developer tools of your browser.\nComputing the SHA-256 The last piece of the puzzle is to compare the meta information that we got from the last version of the file in the repository against the current version of the file stored locally.\nThe meta information of the file includes the field content_sha256 containing the SHA-256 of the file. We can compute the same kind of hash for our file stored locally and then check if the two hashes match.\nWe can use the webcrypto Node.js module which is mostly compatible with the Web Crypto API available in browsers. Again, the only difference between the browser version and the Node.js version should be the way we import modules.\nimport * as fs from 'fs'; import {webcrypto as crypto} from 'crypto'; // ... async function computeHash(contents) { const utf8Encoded = new TextEncoder().encode(contents); const hashBuffer = await crypto.subtle.digest(\u0026quot;SHA-256\u0026quot;, utf8Encoded); const hashBytes = Array.from(new Uint8Array(hashBuffer)); const hashHex = hashBytes.map(b =\u0026gt; b.toString(16).padStart(2, \u0026quot;0\u0026quot;)).join(\u0026quot;\u0026quot;); return hashHex; } const fileContents = fs.readFileSync(\u0026quot;PATH TO LOCAL FILE\u0026quot;); if (computeHash(fileContents) !== fileInfo.content_sha256) { console.error(\u0026quot;Hashes don't match!\u0026quot;); }  Final Thoughts Today we have explored only a single resource from the GitLab REST API and one possible use case. But we have just scratched the surface, there are many other resources which might come in handy when developing your tool or application.\nIf you are like me, and use GitHub instead of or in addition to GitLab, worry not. GitHub also provides a REST API (and GraphQL) with equivalent functionality. In fact, GitHub provides an official library, Octokit, which simplifies the integration with the API.\n","date":"2021-11-28","permalink":"https://alexvia.com/post/004_file_integrity_gitlab_api/","tags":["gitlab","api","rest","javascript","nodejs"],"title":"Checking file integrity using the GitLab API"},{"content":"\nThe Advanced Linux Sound Architecture (ALSA) project is used to implement sound card drivers in Linux. Apart from the Kernel API, ALSA also provides a library API exposing the same functionality as the Kernel API but with a simpler and more usable interface. In this post, we will explore how the PCM Interface can be used for sound playback.\nThere are quite a few options for dealing with audio on Linux. On one hand, we have high level libraries such as SDL or OpenAL that allow us to play a sound with a few lines of code. Then we also have entire frameworks devoted to multimedia such as GStreamer. And we also have sound servers like PulseAudio or JACK that manage the use and access to audio devices, and allow us to deal with complex scenarios involving multiple streams of audio and possibly multiple sound cards.\nBut what all of the above have in common, is that they all use ALSA and its sound card drivers under the hood.\nAudio Concepts Before we dig into the code, let\u0026rsquo;s review some basic audio concepts.\nPulse Code Modulation (PCM) There are many audio formats out there like mp3, aac, wav, Vorbis (.ogg) but the sound card ultimately consumes raw uncompressed PCM data.\nPCM is a way to represent audio signals in a digital format by taking samples at uniform intervals and representing samples with a predefined number of bits with a process called quantization.\nSample rate The sample rate defines how many samples we have per second. It is measured in samples per second or Hz. Commonly used sample rates are 48kHz and 44.1kHz.\nBits per sample (bit depth) In the PCM image above, the samples were in a floating-point format in the range -1 to 1. If we were to encode these samples using a single-precision floating-point number (a regular float in C), then it would take 32 bits to represent each sample. But floats have a wider range than just -1 to 1, so we are wasting space and precision just for the benefit of having nice normalized values.\nAn alternative is to use signed integers, ranging from the minimum representable value to the maximum, instead of -1 to 1. For example, using a 16 bit integer (short in most C compilers), the minimum sample value would be -32768 and the maximum 32767.\nChannels A channel represents sound from a single source like a microphone or a speaker. But it is very common to have multiple channels to represent the recording of multiple microphones at the same time, or for playing a different sound on every speaker.\nMost audio file formats support multiple channels of data. We use the terms mono, when there is a single audio channel and stereo when there are two channels.\nUsing ALSA NOTE: In order to keep the code samples short we have completely skipped error checking in this post. Check out the repository for a more complete implementation.\nTo start using the ALSA library API, we first need to include the asoundlib.h header, containing the definitions for the types and functions that we are going to use.\n#include \u0026lt;alsa/asoundlib.h\u0026gt;  Opening the device When using the PCM interface, the first thing we need to do is open the device with snd_pcm_open. In our case, we want the \u0026ldquo;default\u0026rdquo; stream playback device. When we are done using the device we can close it with snd_pcm_close.\nsnd_pcm_t *pcm; snd_pcm_open(\u0026amp;pcm, \u0026quot;default\u0026quot;, SND_PCM_STREAM_PLAYBACK, 0);  Configuring the device After opening the device, we can configure it with two groups of PCM related parameters. The hardware parameters control hardware-specific parameters for the stream like the sample rate, number of channels or size of the underlying ring buffer. Software parameters define driver related parameters such as how many samples need to be written before starting the stream (start threshold) or if reads and writes to the sound buffer should be aligned or not.\nTo specify the hardware parameters, we need to:\n Allocate a variable of type snd_pcm_hw_params_t either on the stack (snd_pcm_hw_params_alloca), like we will do, or on the heap (snd_pcm_hw_params_malloc). Fill the parameters with the full configuration space for a PCM (snd_pcm_hw_params_any). Restrict the configuration space using snd_pcm_hw_params_set_* functions. \u0026ldquo;Install\u0026rdquo; or set the parameters for the device (snd_pcm_hw_params).  snd_pcm_hw_params_t *hw_params; snd_pcm_hw_params_alloca(\u0026amp;hw_params); snd_pcm_hw_params_any(pcm, hw_params); snd_pcm_hw_params_set_access(pcm, hw_params, SND_PCM_ACCESS_RW_INTERLEAVED); snd_pcm_hw_params_set_format(pcm, hw_params, SND_PCM_FORMAT_S16_LE); snd_pcm_hw_params_set_channels(pcm, hw_params, 1); snd_pcm_hw_params_set_rate(pcm, hw_params, 48000, 0); snd_pcm_hw_params_set_periods(pcm, hw_params, 10, 0); snd_pcm_hw_params_set_period_time(pcm, hw_params, 100000, 0); // 0.1 seconds snd_pcm_hw_params(pcm, hw_params);  Software parameters are configured in a similar fashion, but we won\u0026rsquo;t need to use them for this simple program.\nWriting the samples Now that we have the device configured, we are ready to start writing samples to the device for playback.\nWe start by creating a small intermediate buffer on the stack to store the samples for a second. Then we need to initialize the samples to the sound that we want to play, somehow. Last but not least, we invoke the snd_pcm_writei function passing our intermediate buffer and the number of samples which will get copied to the driver\u0026rsquo;s playback buffer.\nshort samples[48000] = {0}; // Initialize the samples somehow snd_pcm_writei(pcm, samples, 48000);  Closing the Device Finally, we can wait for the device to play all of our samples (snd_pcm_drain) and then we can close the device (snd_pcm_close)\nsnd_pcm_drain(pcm); snd_pcm_close(pcm);  Generating a sine wave Implementing a sine wave function is pretty simple, we just need to apply the formula: y(t) = Asin(2Ï€ft + Ï†)\nIn our case, we have hardcoded the amplitude to 10000 and the phase to 0 and we have converted a sample index (our i variable) to seconds, dividing it by the sampling rate.\nshort *sine_wave(short *buffer, size_t sample_count, int freq) { for (int i = 0; i \u0026lt; sample_count; i++) { buffer[i] = 10000 * sinf(2 * M_PI * freq * ((float)i / SAMPLE_RATE)); } return buffer; } ... snd_pcm_writei(pcm, sine_wave(buffer, SAMPLE_RATE, 200), SAMPLE_RATE);  Generating a square wave To generate a square wave we just have to detect whether the current sample index is on the first half of the period or on the second half, and output the maximum or minimum amplitude respectively.\nWe can easily obtain the number of samples of a full period dividing the sample rate by the frequency.\nshort *square_wave(short *buffer, size_t sample_count, int freq) { int samples_full_cycle = (float)SAMPLE_RATE / (float)freq; int samples_half_cycle = samples_full_cycle / 2.0f; int cycle_index = 0; for (int i = 0; i \u0026lt; sample_count; i++) { buffer[i] = cycle_index \u0026lt; samples_half_cycle ? 10000 : -10000; cycle_index = (cycle_index + 1) % samples_full_cycle; } return buffer; } ... snd_pcm_writei(pcm, square_wave(buffer, SAMPLE_RATE, 200), SAMPLE_RATE);  Playing raw S16LE Instead of generating the sound procedurally we can read sound samples from a raw pcm file and play them.\nI have provided a sample raw file in the repository, but you can also extract/convert a raw pcm from your audio files using the following ffmpeg command:\nffmpeg -i input.mp3 -acodec pcm_s16le -f s16le -ac 1 -ar 48000 output.raw  The good thing about the raw pcm format is that we only need to read it into memory and we can use it directly as the buffer for snd_pcm_writei.\nFILE *f = fopen(\u0026quot;./output.raw\u0026quot;, \u0026quot;rb\u0026quot;); fseek(f, 0, SEEK_END); long file_size = ftell(f); fseek(f, 0, SEEK_SET); short *samples = (short*)malloc(file_size); fread(samples, 1, file_size, f); fclose(f); snd_pcm_writei(pcm, samples, SAMPLE_RATE); free(samples);  What next So far, our code only plays sound for 1 second (48000 samples) and then quits. The implementation in the repo provides options for looping as well as choosing the kind of sound to play.\nA couple of suggested exercises could be, to implement a function for generating a sawtooth wave, or apply the necessary changes to play stereo (2 channels).\nWe have just scratched the surface on the possibilities that ALSA provides, we encourage readers to explore the examples in the documentation.\n","date":"2021-11-19","permalink":"https://alexvia.com/post/003_alsa_playback/","tags":["linux","alsa","c","audio"],"title":"Playing a Sound with ALSA"},{"content":"In the last post, we created a simple program to open an X11 window. Today, we will learn how to initialize and use OpenGL to clear the window with a color.\n\nAnd the result: Linking with OpenGL In order to use OpenGL we need to include the following headers:\n#include \u0026lt;X11/Xutil.h\u0026gt;\t// Required to use XVisualInfo #include \u0026lt;GL/gl.h\u0026gt; // OpenGL types and functions like GLuint or glClear #include \u0026lt;GL/glx.h\u0026gt;\t// OpenGL X Window bindings like glXCreateContext  And we also need to tell the compiler to link with OpenGL:\n# using pkg-config gcc -o x11_opengl `pkg-config --libs x11 gl` x11_opengl.c # on my system evaluates to: gcc -o x11_opengl -lX11 -lGL x11_opengl.c  Creating an OpenGL context Before creating an OpenGL context we need to select a visual by calling glXChooseVisual. This function accepts the connection to the display, a screen number and a list of desired attributes and returns the visual that matches best with the specified attributes.\nIn our case, we want to request a visual with support for TrueColor, double buffering and a 24-bit depth buffer.\nXVisualInfo *visual = glXChooseVisual(display, 0, (int[]){ GLX_RGBA, GLX_DEPTH_SIZE, 24, GLX_DOUBLEBUFFER, None }); printf(\u0026quot;Visual ID: %x\\n\u0026quot;, visual-\u0026gt;visualid); // 2b4 in my environment  We can use the program glxinfo with the flag v glxinfo -v, to check what visuals are supported in our system.\n106 GLX Visuals Visual ID: 20 depth=24 class=TrueColor, type=window,pixmap,pbuffer bufferSize=32 level=0 renderType=rgba doubleBuffer=1 stereo=0 rgba: redSize=8 greenSize=8 blueSize=8 alphaSize=8 float=N sRGB=N auxBuffers=0 depthSize=24 stencilSize=8 accum: redSize=0 greenSize=0 blueSize=0 alphaSize=0 multiSample=0 multiSampleBuffers=0 visualCaveat=None Opaque. ... Visual ID: 2b4 depth=24 class=TrueColor, type=window,pixmap,pbuffer bufferSize=24 level=0 renderType=rgba doubleBuffer=1 stereo=0 rgba: redSize=8 greenSize=8 blueSize=8 alphaSize=0 float=N sRGB=N auxBuffers=0 depthSize=24 stencilSize=8 accum: redSize=0 greenSize=0 blueSize=0 alphaSize=0 multiSample=0 multiSampleBuffers=0 visualCaveat=None Opaque. ...  With the visual selected, we can create the GL context by calling glXCreateContext.\nGLXContext gl_context = glXCreateContext(display, visual, 0, True);  Once we have a valid GL context and we\u0026rsquo;ve also created an X11 window, we can bind them so that OpenGL will render to the window, from this point onward. This is achieved by calling glXMakeCurrent.\nglXMakeCurrent(display, window, gl_context);  Using OpenGL After creating and setting the GL context, we can start making OpenGL calls. We can clear the window background to a dark gray color by calling glClearColor inside our main loop, specifying the red, green, blue and alpha components ranging from 0.0 to 1.0. Followed by a call to glClear specifying that we want to clear the color buffer.\nFinally, since we are using double-buffering we need to call glXSwapBuffers in order to swap the front and back buffers.\nwhile (!quit) { ... glClearColor(0.15, 0.15, 0.15, 1.0); glClear(GL_COLOR_BUFFER_BIT); // render code goes here glXSwapBuffers(display, window); }  Legacy OpenGL (fixed function pipeline) Starting from OpenGL 2.0, shaders were introduced, and from OpenGL 3 onwards many features were marked as deprecated, effectively dividing OpenGL in 2 so called \u0026ldquo;profiles\u0026rdquo;. The OpenGL core profile, with all the deprecated functionality removed, and the OpenGL compatibility profile, keeping the deprecated features.\nWe will be using the fixed function pipeline or \u0026ldquo;Legacy\u0026rdquo; OpenGL here, but we might explore a more modern approach in a future post.\nDrawing a triangle In order to draw a triangle, we can specify the vertices inside a block starting with glBegin and ending with glEnd. The color of the triangle can be specified via one of the variants of glColor, which applies to all the vertices that follow, and vertex positions via glVertex. These coordinates go from (-1.0, -1.0) on the lower left to (1.0, 1.0) on the top right.\nglBegin(GL_TRIANGLES); glColor3f(0.68, 0.84, 0.0); glVertex2f(-0.5, -0.5); glVertex2f( 0.5, -0.5); glVertex2f( 0.0, 0.5); glEnd();  Cleanup Finally, when all the rendering is done, and the application is shutting down, it is good practice to destroy the GL context via glXDestroyContext.\nglXDestroyContext(display, gl_context);  ","date":"2021-11-13","permalink":"https://alexvia.com/post/002_initializing_opengl_on_x11/","tags":["opengl","graphics","x11"],"title":"Initializing OpenGL in X11"},{"content":"The X Window System is a windowing system commonly used in UNIX-based operating systems. The latest version of X is version 11 (released 2012), that\u0026rsquo;s why it\u0026rsquo;s often abbreviated as X11.\nX11 is based on a client-server architecture. The server is the one who has direct access over the hardware devices such as the monitor screens, the keyboard and the mouse. Client applications should make requests to the server in order to achieve any kind of graphical output to the screen.\nX is not the only Window System available for Linux and other UNIX-like operating systems. Wayland is a more modern project with the aim of replacing X.\nPrerequisites  A linux machine (or VM) with X installed and configured The X11 development package libx11-dev (Ubuntu) libx11 (Arch) The code for this post, which you can find here  Implementation Most definitions for X11 can be found in the X11/Xlib.h header, so make sure to include this at the start of your program.\n#include \u0026lt;X11/Xlib.h\u0026gt;  The first thing every X client needs to do is establish a connection with the X server. This is achieved by calling the XOpenDisplay function, which on success, returns a handle representing the connection established, commonly referred to as the \u0026ldquo;display\u0026rdquo;. From this point forward, the display handle can be used to issue commands to the x server, such as creating a window, getting input from the keyboard or drawing text. When the client application is about to quit or it no longer requires access to the Windowing system, it should close the connection by calling the XCloseDisplay function.\nDisplay *display = XOpenDisplay(NULL); // display name  Once we have established a connection to the display, we can start making requests to the X server. For instance, we can request to create a new window by calling XCreateSimpleWindow. We can use XDefaultRootWindow to grab the root window for the display and use it as our parent window. Another way to create a window is by calling XCreateWindow instead, which provides more options for specifying window attributes, but we won\u0026rsquo;t cover it on this post.\nWindow window = XCreateSimpleWindow( display, XDefaultRootWindow(display),\t// parent 0, 0,\t// x, y 800, 600,\t// width, height 0,\t// border width 0x00000000,\t// border color 0x00000000\t// background color );  The XStoreName procedure let\u0026rsquo;s us set a name or caption for the window.\nXStoreName(display, window, \u0026quot;Amazing X11 Window\u0026quot;);  By default, the X server will not report any event to clients in order to save bandwitdh. A client application should specify which events it\u0026rsquo;s interested on, via XSelectInput with a mask of event types. In our case, we are only going to request to be notified about key press and key release events.\nXSelectInput(display, window, KeyPressMask|KeyReleaseMask);  If you ran the program up to this point you would realize that no window is displayed to the screen. We first need to request for the window to be displayed or \u0026ldquo;mapped\u0026rdquo; by calling XMapWindow. You can think of mapping and unmapping as showing and hiding a window.\nXMapWindow(display, window);  At the heart of any graphical application we have the event processing loop. There are many ways of writing an event loop, which may vary depending on the domain of your application, the event loop for a game is going to be different from the event loop for a spreadsheet program or a business management application.\nbool quit = false; while (!quit) { while (XPending(display) \u0026gt; 0) { XEvent event = {0}; XNextEvent(display, \u0026amp;event); if (event.type == KeyPress) { quit = true; } } // Do your application work here }  Finally, as we already discussed, the connection should be closed by calling XCloseDisplay before quitting the application.\nXCloseDisplay(display);  Next steps So far, we have only created the basic skeleton for a GUI application. From here onwards we could start working on many things, such as:\n Drawing to the window Add and improve event handling Make use of hardware accelerated graphics via OpenGL or Vulkan  But we will leave that for next time ðŸ˜‰\n","date":"2021-11-07","permalink":"https://alexvia.com/post/001_xlib_opening_window/","tags":["linux","gui","coding"],"title":"Opening a Window in X11"},{"content":"At a fundamental level a pointer is just a number which represents a memory address. The size of a pointer depends on the platform, for 64 bit platforms the size is 64 bits (8 bytes) and for 32 bit platforms the size is 32 bits (4 bytes), but the size is always the same for a given platform regardless of the pointer\u0026rsquo;s type.\nprintf(\u0026quot;%d\\n\u0026quot;, sizeof(int*)); printf(\u0026quot;%d\\n\u0026quot;, sizeof(char*)); printf(\u0026quot;%d\\n\u0026quot;, sizeof(void*)); printf(\u0026quot;%d\\n\u0026quot;, sizeof(MyCustomType*));  A memory address specifies the location of a single byte in memory, if we wanted to read only a single bit from memory, we would have to read a whole byte and then do some bit twiddling to extract the bit we were interested in.\n1. Modify another variable\u0026rsquo;s value The most basic usage of pointers is to modify the value of the variable they are pointing to. The address-of operator \u0026amp; is used to get the memory address of a variable, which we can then assign to a variable of type pointer. Once we have a pointer initialized we can read or modify the variable we are pointing to by using the derreference operator *.\nint foo = 10; int *ptr = \u0026amp;foo; // Get the address of foo and store it in the pointer ptr. *ptr = 20; // Modify the value pointed to by ptr (foo). printf(\u0026quot;foo: %d\\n\u0026quot;, foo);  2. Calling \u0026ldquo;by pointer\u0026rdquo; We can achieve the same result as before but in a function by passing the argument \u0026ldquo;by pointer\u0026rdquo;:\nvoid my_func(int *ptr) { *ptr = 20; } int main() { int foo = 10; my_func(\u0026amp;foo); printf(\u0026quot;foo: %d\\n, foo); }  In this simple example, it might not be clear which are the benefits of passing foo by pointer instead of just returning the value 20 directly and assigning it to foo like this:\nint my_func() { return 20; } int main() { int foo = 10; foo = my_func(); printf(\u0026quot;foo: %d\\n\u0026quot;, foo); }  But whereas you can only return a single value, you can have multiple parameters of type pointer. So, this method is useful when you want to have multiple return values.\n3. String literals Pointers are also very commonly used to store the address of string literals.\nchar *message = \u0026quot;You Rock!\u0026quot;;  These literals are typically stored in a read-only section of the executable binary, therefore the content of these literals cannot be modified.\n// message[0] = 'y'; // This produces an error at runtime!  The pointer value that we get back when creating a string literal always refers to the memory address of the first character, and the string literal is always null terminated.\n#include \u0026lt;stdio.h\u0026gt; int main() { char *message = \u0026quot;You Rock!\u0026quot;; printf(\u0026quot;The first character is: '%c' which is the same as '%c'\\n\u0026quot;, message[0], *message); printf(\u0026quot;The literal \\\u0026quot;%s\\\u0026quot; is located at address: 0x%08X\\n\u0026quot;, message, message); message = \u0026quot;You're amazing!\u0026quot;; printf(\u0026quot;The literal \\\u0026quot;%s\\\u0026quot; is located at address: 0x%08X\\n\u0026quot;, message, message); printf(\u0026quot;The string ends with %d\\n\u0026quot;, *(message + 15)); }  4. Allocating memory Another usage is to store a pointer to a block of allocated memory. The C standard library stdlib.h provides the malloc function which takes a size in bytes and returns a pointer to the start of a block of memory with the size we specified on success, or a NULL pointer on failure.\nchar *buffer = (char*)malloc(1024); // allocate a block of 1024 bytes  Usually, the operating system provides its own set of functions to allocate memory, which give the user more control over how the allocation is done.\nOn Windows, we have the function VirtualAlloc which allows us to specify, among other things, which permissions do we want for the allocated memory, do we want write only memory or we also want to have execute access.\nOn Linux, the function mmap is used to map a file into memory, but the same function can be used to allocate memory by setting the flag MAP_ANONYMOUS.\n5. Arrays In C, arrays are just a contiguous region of memory with enough size to fit the elements we specify. The compiler implicitly keeps information about the size of an array, and we also know the size of a single element in the array. Therefore, we can compute the number of elements by dividing these two values.\nint numbers[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; printf(\u0026quot;sizeof(numbers): %d\\n\u0026quot;, sizeof(numbers)); // sizeof(int) * 10 int count = sizeof(numbers) / sizeof(numbers[0]); // 10  There is a catch though, when we pass the array as an argument to a function that information is lost. In fact, the function declarations void foo(int arr[]); and void foo(int *arr); are equivalent.\nvoid print_size(int arr[]) { // Warning on most compilers. Prints the same as sizeof(int*) printf(\u0026quot;sizeof(arr): %d\\n\u0026quot;, sizeof(arr)); } int main() { int numbers[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; print_size(numbers); // numbers is passed as if it was an int* }  Since the array size information is lost when calling other functions, it is very common to have an extra function parameter that specifies how many elements are in the array.\nvoid print_array(int arr[], int count) { for (int i = 0; i \u0026lt; count; i++) { printf(\u0026quot;%d\\n\u0026quot;, arr[i]); } }  The parameters argc and argv in the main function is another example of this. In this case, the type of each element in the array argv is char *, which is itself a null-terminated array of characters.\nint main(int argc, char **argv) { for (int i = 0; i \u0026lt; argc; i++) { printf(\u0026quot;argument[%d]: %s\\n\u0026quot;, i, argv[i]); } }  6. Data structures Pointers are also fundamental to many data structures such as Single and Doubly Linked Lists or Trees. The discussion of these data structures is out of the scope of this post, but we will show how some of this structures could be defined using pointers.\ntypedef struct { ListNode *prev; ListNode *next; // Any additional data } ListNode;  typedef struct { TreeNode *left; TreeNode *right; // Any additional data } TreeNode;  7. Function pointers Just as variables have an address where their value is stored, functions also have an address, in this case though, it\u0026rsquo;s the address where the executable code of the function is located. We can get the address of a function just by its name, we don\u0026rsquo;t need to use the \u0026amp; operator.\nint sum(int a, int b) { return a + b; } int main() { printf(\u0026quot;The address of sum is 0x%08X\\n\u0026quot;, sum); }  The syntax for specifying the type of function pointers is a bit tricky, but you can always look it up or use cdecl.org. In our case the type would be int (*fptr_name)(int, int). And once, we have a pointer to the function, we cani just call it like if it was a regular function.\nint sum(int a, int b) {/*...*/} int main() { int (*sum_fptr)(int, int) = sum; printf(\u0026quot;1 + 2 = %d\\n\u0026quot;, sum_fptr(1, 2)); }  8. Opaque types This last usage is often used by libraries as a way to keep implementation details hidden from the users of the library. More specifically, what is hidden from the users is the definition of internal structs within the library. That way, the mantainers of the library can change the internal definition of the structs without affecting the users.\nLet\u0026rsquo;s imagine that we were the authors of a library for creating a window. We could define a simple API for the library in the header file window.h like this:\n// window.h typedef struct Window Window; Window *create(int width, int height); void show(Window *window); void destroy(Window *window);  In the first line, we declare an incomplete type Window. This allows us, to use this type without knowing the actual structure layout, as long as we use it as a pointer. And the compiler know, that the actual definition of the struct will come later. Following the declaration of Window we have the prototypes of 3 functions for creating, showing and destroying a window. Notice how all of these methods either return a pointer to Window or take a parameter of type pointer to Window.\nUsers can start using the library, and they cannot see which fields there are inside of a Window. That is a good thing, because if the authors of the library ever decided to release a new version changing the internals of the Window struct, the user\u0026rsquo;s code should still compile without changes.\n// main.c #include \u0026quot;window.h\u0026quot; int main() { Window *window = create(800, 600); show(window); destroy(window); }  The internal implementation of the library could look something like this:\n// window.c #include \u0026quot;window.h\u0026quot; #include \u0026lt;stdio.h\u0026gt; typedef struct Window { int handle; // Fields private to this file } Window; Window *create(int width, int height) { Window *window = (Window*)malloc(sizeof(Window)); window-\u0026gt;handle = 123; // Simulate that we created a window handle return window; } void show(Window *window) { printf(\u0026quot;Showing the window\\n\u0026quot;); } void destroy(Window *window) { if (window) { free(window); } }  The same concept can be applied to cross platform code. In this case we could have one implementation file for every supported platform, for example win32_window.c and linux_window.c and the actual definition of the Window struct could be different.\nConclusion We have seen that the concept of pointers is very simple at a fundamental level. However, there are many ways they can be used which is why sometimes it can get confusing. Figuring out which of the use cases presented in this post is being used at any point can help you avoid the confusion.\n","date":"2021-10-31","permalink":"https://alexvia.com/post/000_uses_of_pointers_in_c/","tags":["beginner","coding","c"],"title":"8 Uses of Pointers in C"}]