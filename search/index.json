[{"content":"The X Window System is a windowing system commonly used in UNIX-based operating systems. The latest version of X is version 11 (released 2012), that\u0026rsquo;s why it\u0026rsquo;s often abbreviated as X11.\nX11 is based on a client-server architecture. The server is the one who has direct access over the hardware devices such as the monitor screens, the keyboard and the mouse. Client applications should make requests to the server in order to achieve any kind of graphical output to the screen.\nX is not the only Window System available for Linux and other UNIX-like operating systems. Wayland is a more modern project with the aim of replacing X.\nPrerequisites  A linux machine (or VM) with X installed and configured The X11 development package libx11-dev (Ubuntu) libx11 (Arch) The code for this post, which you can find here  Implementation Most definitions for X11 can be found in the X11/Xlib.h header, so make sure to include this at the start of your program.\n#include \u0026lt;X11/Xlib.h\u0026gt;  The first thing every X client needs to do is establish a connection with the X server. This is achieved by calling the XOpenDisplay function, which on success, returns a handle representing the connection established, commonly referred to as the \u0026ldquo;display\u0026rdquo;. From this point forward, the display handle can be used to issue commands to the x server, such as creating a window, getting input from the keyboard or drawing text. When the client application is about to quit or it no longer requires access to the Windowing system, it should close the connection by calling the XCloseDisplay function.\nDisplay *display = XOpenDisplay(NULL); // display name  Once we have established a connection to the display, we can start making requests to the X server. For instance, we can request to create a new window by calling XCreateSimpleWindow. We can use XDefaultRootWindow to grab the root window for the display and use it as our parent window. Another way to create a window is by calling XCreateWindow instead, which provides more options for specifying window attributes, but we won\u0026rsquo;t cover it on this post.\nWindow window = XCreateSimpleWindow( display, XDefaultRootWindow(display),\t// parent 0, 0,\t// x, y 800, 600,\t// width, height 0,\t// border width 0x00000000,\t// border color 0x00000000\t// background color );  The XStoreName procedure let\u0026rsquo;s us set a name or caption for the window.\nXStoreName(display, window, \u0026quot;Amazing X11 Window\u0026quot;);  By default, the X server will not report any event to clients in order to save bandwitdh. A client application should specify which events it\u0026rsquo;s interested on, via XSelectInput with a mask of event types. In our case, we are only going to request to be notified about key press and key release events.\nXSelectInput(display, window, KeyPressMask|KeyReleaseMask);  If you ran the program up to this point you would realize that no window is displayed to the screen. We first need to request for the window to be displayed or \u0026ldquo;mapped\u0026rdquo; by calling XMapWindow. You can think of mapping and unmapping as showing and hiding a window.\nXMapWindow(display, window);  At the heart of any graphical application we have the event processing loop. There are many ways of writing an event loop, which may vary depending on the domain of your application, the event loop for a game is going to be different from the event loop for a spreadsheet program or a business management application.\nbool quit = false; while (!quit) { while (XPending(display) \u0026gt; 0) { XEvent event = {0}; XNextEvent(display, \u0026amp;event); if (event.type == KeyPress) { quit = true; } } // Do your application work here }  Finally, as we already discussed, the connection should be closed by calling XCloseDisplay before quitting the application.\nXCloseDisplay(display);  Next steps So far, we have only created the basic skeleton for a GUI application. From here onwards we could start working on many things, such as:\n Drawing to the window Add and improve event handling Make use of hardware accelerated graphics via OpenGL or Vulkan  But we will leave that for next time ðŸ˜‰\n","date":"2021-11-07","permalink":"https://alexvia.com/post/xlib_opening_window/","tags":["linux","gui","coding"],"title":"Opening a Window in X11"},{"content":"At a fundamental level a pointer is just a number which represents a memory address. The size of a pointer depends on the platform, for 64 bit platforms the size is 64 bits (8 bytes) and for 32 bit platforms the size is 32 bits (4 bytes), but the size is always the same for a given platform regardless of the pointer\u0026rsquo;s type.\nprintf(\u0026quot;%d\\n\u0026quot;, sizeof(int*)); printf(\u0026quot;%d\\n\u0026quot;, sizeof(char*)); printf(\u0026quot;%d\\n\u0026quot;, sizeof(void*)); printf(\u0026quot;%d\\n\u0026quot;, sizeof(MyCustomType*));  A memory address specifies the location of a single byte in memory, if we wanted to read only a single bit from memory, we would have to read a whole byte and then do some bit twiddling to extract the bit we were interested in.\n1. Modify another variable\u0026rsquo;s value The most basic usage of pointers is to modify the value of the variable they are pointing to. The address-of operator \u0026amp; is used to get the memory address of a variable, which we can then assign to a variable of type pointer. Once we have a pointer initialized we can read or modify the variable we are pointing to by using the derreference operator *.\nint foo = 10; int *ptr = \u0026amp;foo; // Get the address of foo and store it in the pointer ptr. *ptr = 20; // Modify the value pointed to by ptr (foo). printf(\u0026quot;foo: %d\\n\u0026quot;, foo);  2. Calling \u0026ldquo;by pointer\u0026rdquo; We can achieve the same result as before but in a function by passing the argument \u0026ldquo;by pointer\u0026rdquo;:\nvoid my_func(int *ptr) { *ptr = 20; } int main() { int foo = 10; my_func(\u0026amp;foo); printf(\u0026quot;foo: %d\\n, foo); }  In this simple example, it might not be clear which are the benefits of passing foo by pointer instead of just returning the value 20 directly and assigning it to foo like this:\nint my_func() { return 20; } int main() { int foo = 10; foo = my_func(); printf(\u0026quot;foo: %d\\n\u0026quot;, foo); }  But whereas you can only return a single value, you can have multiple parameters of type pointer. So, this method is useful when you want to have multiple return values.\n3. String literals Pointers are also very commonly used to store the address of string literals.\nchar *message = \u0026quot;You Rock!\u0026quot;;  These literals are typically stored in a read-only section of the executable binary, therefore the content of these literals cannot be modified.\n// message[0] = 'y'; // This produces an error at runtime!  The pointer value that we get back when creating a string literal always refers to the memory address of the first character, and the string literal is always null terminated.\n#include \u0026lt;stdio.h\u0026gt; int main() { char *message = \u0026quot;You Rock!\u0026quot;; printf(\u0026quot;The first character is: '%c' which is the same as '%c'\\n\u0026quot;, message[0], *message); printf(\u0026quot;The literal \\\u0026quot;%s\\\u0026quot; is located at address: 0x%08X\\n\u0026quot;, message, message); message = \u0026quot;You're amazing!\u0026quot;; printf(\u0026quot;The literal \\\u0026quot;%s\\\u0026quot; is located at address: 0x%08X\\n\u0026quot;, message, message); printf(\u0026quot;The string ends with %d\\n\u0026quot;, *(message + 15)); }  4. Allocating memory Another usage is to store a pointer to a block of allocated memory. The C standard library stdlib.h provides the malloc function which takes a size in bytes and returns a pointer to the start of a block of memory with the size we specified on success, or a NULL pointer on failure.\nchar *buffer = (char*)malloc(1024); // allocate a block of 1024 bytes  Usually, the operating system provides its own set of functions to allocate memory, which give the user more control over how the allocation is done.\nOn Windows, we have the function VirtualAlloc which allows us to specify, among other things, which permissions do we want for the allocated memory, do we want write only memory or we also want to have execute access.\nOn Linux, the function mmap is used to map a file into memory, but the same function can be used to allocate memory by setting the flag MAP_ANONYMOUS.\n5. Arrays In C, arrays are just a contiguous region of memory with enough size to fit the elements we specify. The compiler implicitly keeps information about the size of an array, and we also know the size of a single element in the array. Therefore, we can compute the number of elements by dividing these two values.\nint numbers[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; printf(\u0026quot;sizeof(numbers): %d\\n\u0026quot;, sizeof(numbers)); // sizeof(int) * 10 int count = sizeof(numbers) / sizeof(numbers[0]); // 10  There is a catch though, when we pass the array as an argument to a function that information is lost. In fact, the function declarations void foo(int arr[]); and void foo(int *arr); are equivalent.\nvoid print_size(int arr[]) { // Warning on most compilers. Prints the same as sizeof(int*) printf(\u0026quot;sizeof(arr): %d\\n\u0026quot;, sizeof(arr)); } int main() { int numbers[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; print_size(numbers); // numbers is passed as if it was an int* }  Since the array size information is lost when calling other functions, it is very common to have an extra function parameter that specifies how many elements are in the array.\nvoid print_array(int arr[], int count) { for (int i = 0; i \u0026lt; count; i++) { printf(\u0026quot;%d\\n\u0026quot;, arr[i]); } }  The parameters argc and argv in the main function is another example of this. In this case, the type of each element in the array argv is char *, which is itself a null-terminated array of characters.\nint main(int argc, char **argv) { for (int i = 0; i \u0026lt; argc; i++) { printf(\u0026quot;argument[%d]: %s\\n\u0026quot;, i, argv[i]); } }  6. Data structures Pointers are also fundamental to many data structures such as Single and Doubly Linked Lists or Trees. The discussion of these data structures is out of the scope of this post, but we will show how some of this structures could be defined using pointers.\ntypedef struct { ListNode *prev; ListNode *next; // Any additional data } ListNode;  typedef struct { TreeNode *left; TreeNode *right; // Any additional data } TreeNode;  7. Function pointers Just as variables have an address where their value is stored, functions also have an address, in this case though, it\u0026rsquo;s the address where the executable code of the function is located. We can get the address of a function just by its name, we don\u0026rsquo;t need to use the \u0026amp; operator.\nint sum(int a, int b) { return a + b; } int main() { printf(\u0026quot;The address of sum is 0x%08X\\n\u0026quot;, sum); }  The syntax for specifying the type of function pointers is a bit tricky, but you can always look it up or use cdecl.org. In our case the type would be int (*fptr_name)(int, int). And once, we have a pointer to the function, we cani just call it like if it was a regular function.\nint sum(int a, int b) {/*...*/} int main() { int (*sum_fptr)(int, int) = sum; printf(\u0026quot;1 + 2 = %d\\n\u0026quot;, sum_fptr(1, 2)); }  8. Opaque types This last usage is often used by libraries as a way to keep implementation details hidden from the users of the library. More specifically, what is hidden from the users is the definition of internal structs within the library. That way, the mantainers of the library can change the internal definition of the structs without affecting the users.\nLet\u0026rsquo;s imagine that we were the authors of a library for creating a window. We could define a simple API for the library in the header file window.h like this:\n// window.h typedef struct Window Window; Window *create(int width, int height); void show(Window *window); void destroy(Window *window);  In the first line, we declare an incomplete type Window. This allows us, to use this type without knowing the actual structure layout, as long as we use it as a pointer. And the compiler know, that the actual definition of the struct will come later. Following the declaration of Window we have the prototypes of 3 functions for creating, showing and destroying a window. Notice how all of these methods either return a pointer to Window or take a parameter of type pointer to Window.\nUsers can start using the library, and they cannot see which fields there are inside of a Window. That is a good thing, because if the authors of the library ever decided to release a new version changing the internals of the Window struct, the user\u0026rsquo;s code should still compile without changes.\n// main.c #include \u0026quot;window.h\u0026quot; int main() { Window *window = create(800, 600); show(window); destroy(window); }  The internal implementation of the library could look something like this:\n// window.c #include \u0026quot;window.h\u0026quot; #include \u0026lt;stdio.h\u0026gt; typedef struct Window { int handle; // Fields private to this file } Window; Window *create(int width, int height) { Window *window = (Window*)malloc(sizeof(Window)); window-\u0026gt;handle = 123; // Simulate that we created a window handle return window; } void show(Window *window) { printf(\u0026quot;Showing the window\\n\u0026quot;); } void destroy(Window *window) { if (window) { free(window); } }  The same concept can be applied to cross platform code. In this case we could have one implementation file for every supported platform, for example win32_window.c and linux_window.c and the actual definition of the Window struct could be different.\nConclusion We have seen that the concept of pointers is very simple at a fundamental level. However, there are many ways they can be used which is why sometimes it can get confusing. Figuring out which of the use cases presented in this post is being used at any point can help you avoid the confusion.\n","date":"2021-10-31","permalink":"https://alexvia.com/post/uses_of_pointers_in_c/","tags":["beginner","coding","c"],"title":"8 Uses of Pointers in C"}]